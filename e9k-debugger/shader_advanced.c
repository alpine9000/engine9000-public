/*
 * COPYRIGHT Â© 2026 Enable Software Pty Ltd - All Rights Reserved
 *
 * https://github.com/alpine9000/engine9000-public
 *
 * See COPYING for license details
 */

#include "shader_advanced.h"

static const char *
shader_advanced_crtFragmentSourceInternal(void)
{
    return
        "#version 120\n"
        "uniform sampler2D u_tex;\n"
        "uniform vec2 u_texSize;\n"
        "uniform float u_geom;\n"
        "uniform float u_scan;\n"
        "uniform float u_beam;\n"
        "uniform float u_scanStrength;\n"
        "uniform float u_maskStrength;\n"
        "uniform float u_maskScale;\n"
        "uniform float u_maskType;\n"
        "uniform float u_grille;\n"
        "uniform float u_grilleStrength;\n"
        "uniform float u_beamStrength;\n"
        "uniform float u_beamWidth;\n"
        "uniform float u_curvatureK;\n"
        "uniform float u_overscan;\n"
        "uniform float u_gamma;\n"
        "uniform float u_chroma;\n"
        "uniform vec2 u_dstSize;\n"
        "uniform vec2 u_dstOffset;\n"
        "float cubic(float x, float a) {\n"
        "  x = abs(x);\n"
        "  if (x < 1.0) {\n"
        "    return (a + 2.0) * x * x * x - (a + 3.0) * x * x + 1.0;\n"
        "  }\n"
        "  if (x < 2.0) {\n"
        "    return a * x * x * x - 5.0 * a * x * x + 8.0 * a * x - 4.0 * a;\n"
        "  }\n"
        "  return 0.0;\n"
        "}\n"
        "vec3 sampleH(float xPix, float yPixCenter, float gammaEnable) {\n"
        "  float a = -0.5;\n"
        "  float x0 = floor(xPix);\n"
        "  float f = xPix - x0;\n"
        "  float w0 = cubic(f + 1.0, a);\n"
        "  float w1 = cubic(f, a);\n"
        "  float w2 = cubic(1.0 - f, a);\n"
        "  float w3 = cubic(2.0 - f, a);\n"
        "  float wSum = w0 + w1 + w2 + w3;\n"
        "  float yUv = yPixCenter / u_texSize.y;\n"
        "  vec3 c0 = texture2D(u_tex, vec2((x0 - 1.0 + 0.5) / u_texSize.x, yUv)).rgb;\n"
        "  vec3 c1 = texture2D(u_tex, vec2((x0 + 0.0 + 0.5) / u_texSize.x, yUv)).rgb;\n"
        "  vec3 c2 = texture2D(u_tex, vec2((x0 + 1.0 + 0.5) / u_texSize.x, yUv)).rgb;\n"
        "  vec3 c3 = texture2D(u_tex, vec2((x0 + 2.0 + 0.5) / u_texSize.x, yUv)).rgb;\n"
        "  if (gammaEnable > 0.5) {\n"
        "    c0 = pow(c0, vec3(2.2));\n"
        "    c1 = pow(c1, vec3(2.2));\n"
        "    c2 = pow(c2, vec3(2.2));\n"
        "    c3 = pow(c3, vec3(2.2));\n"
        "  }\n"
        "  vec3 outC = (c0 * w0 + c1 * w1 + c2 * w2 + c3 * w3);\n"
        "  if (wSum > 0.0) {\n"
        "    outC /= wSum;\n"
        "  }\n"
        "  return outC;\n"
        "}\n"
        "void main() {\n"
        "  vec2 uv = gl_TexCoord[0].st;\n"
        "  vec2 p = uv * 2.0 - 1.0;\n"
        "  float aspect = (u_dstSize.y > 0.0) ? (u_dstSize.x / u_dstSize.y) : 1.0;\n"
        "  vec2 pa = vec2(p.x * aspect, p.y);\n"
        "  float r2 = dot(pa, pa);\n"
        "  float k = u_curvatureK;\n"
        "  float scale = 1.0 - k * r2;\n"
        "  scale = max(scale, 0.5);\n"
        "  float geo = step(0.5, u_geom);\n"
        "  float useScale = mix(1.0, scale, geo);\n"
        "  float useOverscan = mix(1.0, u_overscan, geo);\n"
        "  vec2 p2 = (p / useScale) / useOverscan;\n"
        "  vec2 uv2 = (p2 + 1.0) * 0.5;\n"
        "  if (uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0) {\n"
        "    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
        "    return;\n"
        "  }\n"
        "  float gammaEnable = step(0.5, u_gamma);\n"
        "  float scanEnable = step(0.5, u_scan);\n"
        "  float beamEnable = step(0.5, u_beam);\n"
        "  float chromaEnable = step(0.5, u_chroma);\n"
        "  float scanStrength = clamp(u_scanStrength, 0.0, 1.0);\n"
        "  float maskStrength = clamp(u_maskStrength, 0.0, 1.0);\n"
        "  float maskScale = max(u_maskScale, 1.0);\n"
        "  float grilleEnable = step(0.5, u_grille);\n"
        "  float grilleStrength = clamp(u_grilleStrength, 0.0, 1.0);\n"
        "  float beamStrength = clamp(u_beamStrength, 0.0, 1.0);\n"
        "  float beamWidth = max(u_beamWidth, 0.05);\n"
        "  float maskType = floor(u_maskType + 0.5);\n"
        "  float xPix = uv2.x * u_texSize.x - 0.5;\n"
        "  float yPix = uv2.y * u_texSize.y - 0.5;\n"
        "  float yBase = floor(yPix) + 0.5;\n"
        "  float dy = yPix - yBase;\n"
        "  vec3 cCenter = sampleH(xPix, yBase, gammaEnable);\n"
        "  float lum = dot(cCenter, vec3(0.2126, 0.7152, 0.0722));\n"
        "  float sigma = mix(0.25, 0.85, clamp(lum, 0.0, 1.0)) * beamWidth;\n"
        "  sigma = max(sigma, 0.05);\n"
        "  float inv2s2 = 1.0 / (2.0 * sigma * sigma);\n"
        "  vec3 cM2 = sampleH(xPix, yBase - 2.0, gammaEnable);\n"
        "  vec3 cM1 = sampleH(xPix, yBase - 1.0, gammaEnable);\n"
        "  vec3 cP1 = sampleH(xPix, yBase + 1.0, gammaEnable);\n"
        "  vec3 cP2 = sampleH(xPix, yBase + 2.0, gammaEnable);\n"
        "  float wM2 = exp(-((dy + 2.0) * (dy + 2.0)) * inv2s2);\n"
        "  float wM1 = exp(-((dy + 1.0) * (dy + 1.0)) * inv2s2);\n"
        "  float w0  = exp(-(dy * dy) * inv2s2);\n"
        "  float wP1 = exp(-((dy - 1.0) * (dy - 1.0)) * inv2s2);\n"
        "  float wP2 = exp(-((dy - 2.0) * (dy - 2.0)) * inv2s2);\n"
        "  float wSum = wM2 + wM1 + w0 + wP1 + wP2;\n"
        "  vec3 cBeam = (cM2 * wM2 + cM1 * wM1 + cCenter * w0 + cP1 * wP1 + cP2 * wP2) / wSum;\n"
        "  vec3 c = mix(cCenter, cBeam, beamEnable * beamStrength);\n"
        "  if (chromaEnable > 0.5) {\n"
        "    float chromaShift = 0.35;\n"
        "    vec3 cR = sampleH(xPix - chromaShift, yBase, gammaEnable);\n"
        "    vec3 cB = sampleH(xPix + chromaShift, yBase, gammaEnable);\n"
        "    c = vec3(cR.r, c.g, cB.b);\n"
        "  }\n"
        "  float gap = 1.0 - clamp(abs(dy) * 2.0, 0.0, 1.0);\n"
        "  float scanMin = mix(1.0, 0.65, scanStrength);\n"
        "  float scan = mix(1.0, mix(scanMin, 1.0, gap), scanEnable);\n"
        "  c *= scan;\n"
        "  if (scanEnable > 0.5) {\n"
        "    vec2 frag = gl_FragCoord.xy - u_dstOffset;\n"
        "    float cellX = floor(frag.x / maskScale);\n"
        "    float cellY = floor(frag.y / maskScale);\n"
        "    float idx = mod(cellX, 3.0);\n"
        "    if (maskType < 0.5) {\n"
        "      idx = mod(cellX + mod(cellY, 2.0), 3.0);\n"
        "    } else if (maskType > 1.5) {\n"
        "      float row = mod(cellY, 2.0);\n"
        "      idx = mod(cellX + row, 3.0);\n"
        "    }\n"
        "    float other = mix(1.0, 0.78, maskStrength);\n"
        "    float sel = mix(1.0, 1.06, maskStrength);\n"
        "    vec3 m = vec3(other);\n"
        "    if (idx < 1.0) {\n"
        "      m.r = sel;\n"
        "    } else if (idx < 2.0) {\n"
        "      m.g = sel;\n"
        "    } else {\n"
        "      m.b = sel;\n"
        "    }\n"
        "    if (maskType > 1.5) {\n"
        "      float slot = mix(0.92, 1.0, mod(cellY, 2.0));\n"
        "      m *= slot;\n"
        "    }\n"
        "    if (grilleEnable > 0.5) {\n"
        "      float fx = fract(frag.x / maskScale);\n"
        "      float edge = min(fx, 1.0 - fx);\n"
        "      float w = 0.18;\n"
        "      float wire = smoothstep(0.0, w, edge);\n"
        "      float g = mix(1.0, wire, grilleStrength);\n"
        "      m *= g;\n"
        "    }\n"
        "    c *= m;\n"
        "  }\n"
        "  float vignette = 1.0 - 0.25 * r2;\n"
        "  vignette = clamp(vignette, 0.6, 1.0);\n"
        "  float vignetteOut = mix(1.0, vignette, geo);\n"
        "  c *= vignetteOut;\n"
        "  if (gammaEnable > 0.5) {\n"
        "    c = pow(max(c, vec3(0.0)), vec3(1.0 / 2.2));\n"
        "  }\n"
        "  gl_FragColor = vec4(c, 1.0);\n"
        "}\n";
}

const char *
shader_advanced_crtFragmentSource(void)
{
    return shader_advanced_crtFragmentSourceInternal();
}
